import random
from itertools import product

from helpers.constants import COMP_NODES, NODES


# HELPERS
def _node_encoder(nodes=NODES):
    """
    A local function which generates a list of size "size" with random nodes
    from "nodes".

    :param nodes: List of nodes candidates
    :return: A 20-mer strand with randomly picked nodes from "nodes"
    """
    return ''.join((nodes[random.randint(0, len(nodes) - 1)] for _ in range(20)))


def _concat_nodes(network, node_a, node_b):
    """
    A local function which concats the 3' 10-mer of node_a with the 5' 10-mer of node_b

    :param network: A network dictionary
    :param node_a: First node, which will give the 3' 10-mer
    :param node_b: Second node, which will give the 5' 10-mer
    :return: a strand with the result of concatenating pieces of two DNA sequences
    """
    try:  # node_a 5' + node_b 3'
        return network[node_a][-10:] + network[node_b][:10]
    except KeyError as e:
        print('Wrong node name')
        print(e)
        exit(1)


# FUNCTIONS
def complement_generator(nodes):
    """

    :param nodes: a DNA strand
    :return: the complement of the supplied DNA strand
    """
    return ''.join([COMP_NODES[NODES.index(node)] for node in nodes])


def network_generator(graph):
    """
    Generates a network dictionary from the graph

    :param graph: graph object returned from networkx.read_edgelist method
    :return: a key-value pair of nodes with a DNA sequence attached
    """
    return {node: _node_encoder() for node in graph.nodes()}


def edges_encoder(graph, network):
    """
    Generates an edges dictionary with the DNA sequence concatenated using a
    slice of a 3' 10-mer strand and a 5' 10-mer strand

    :param graph: graph object returned from networkx.read_edgelist method
    :param network: network generated by network_generator
    :return: a key-value pair of edges with a DNA sequence attached
    """
    edges = graph.edges()
    return {
        (node_a, node_b): _concat_nodes(network, node_a, node_b)
        for (node_a, node_b) in product(graph.nodes(), repeat=2)
        if (node_a, node_b) in edges
    }